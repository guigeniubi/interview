1. try/catch 只能捕获当前调用栈中的同步错误

   - 例：`try { setTimeout(() => { throw e }, 0) } catch {}` 捕不到，因为错误发生在另一个宏任务里。

2. async 函数里 throw 等价于返回一个 rejected Promise

   - 例：`async function f(){ throw e }` 等价于 `return Promise.reject(e)`。

3. await 的“错误”会被外层 try/catch 捕获

   - 因为 await 会把 rejection 以抛错的形式恢复出来。

4. Promise 链的错误传播

   - then 回调里 throw 会把链变成 rejected；
   - 如果链条最后没有 .catch，浏览器会触发 unhandledrejection 事件（Node 里是 unhandledRejection）。

5. 并发的错误传播

   - Promise.all：只要有一个 reject => 整体 reject（其余结果丢失）；
   - Promise.allSettled：永不 reject，给出每个任务的 {status, value/reason}。

6. 要捕获计时器/回调中的错误
   - 方案 A：把异步源头包装成 Promise 并 await
   - 方案 B：在回调内部自己 try/catch（仅限同步抛错）

**小雷区：**

- `try { Promise.reject('x') } catch {}` 捕不到；要么 await，要么 .catch。
- `return await something()` vs `return something()`：
  - 前者会把 something() 的 reject 以抛错形式穿过函数作用域（可被函数内部 try/catch 抓住）；
  - 后者直接把一个 rejected promise 向上返回（函数内抓不到）。
