# React Diff 算法

## 背景

- 虚拟 DOM 更新需要比较新旧树，最笨的方式是逐节点对比，复杂度 O(n³)。
- React 采用启发式算法，将复杂度降低到 O(n)。

## 核心策略

1. **同层比较**

   - 只在同一层级比较节点，不会跨层比较。
   - 如果元素跨层移动，React 会认为是删除旧节点 + 新建新节点。

2. **同类型复用，不同类型重建**

   - 如果节点类型相同（如 `<div>` -> `<div>`），则复用并更新属性。
   - 如果节点类型不同（如 `<div>` -> `<span>`），则直接销毁旧节点，新建新节点。

3. **列表 Diff & key 的作用**

   - React 默认按顺序比较子节点。
   - 如果没有 key，在中间插入/删除会导致大量错误的重建。
   - key 能帮助 React 精确识别节点，避免不必要的销毁和创建。

   **示例**：

   ```jsx
   // 初始
   <ul>
     <li key="a">A</li>
     <li key="b">B</li>
     <li key="c">C</li>
   </ul>

   // 更新后
   <ul>
     <li key="a">A</li>
     <li key="d">D</li>
     <li key="b">B</li>
     <li key="c">C</li>
   </ul>
   ```

   - 有 key：只新增 D。
   - 没 key：B、C 都会被错误地替换。

## 算法复杂度

- 通过以上策略，React 将 Diff 算法复杂度从 O(n³) 优化为 O(n)。

## 面试考点

- key 的作用是什么？为什么不能用 index？
  - index 会变化，可能导致错误的复用。
- React 如何处理跨层节点？
  - 直接删除 + 新建。
- Diff 算法和 Fiber 架构关系？
  - Fiber 是调度和渲染架构，Diff 算法在 Fiber 上运行，核心策略没变。
