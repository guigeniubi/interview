**Q2: SSE 流式响应是如何实现的？**  
A:

- 通过 `fetch` 发送带有 `textStreaming: true` 的请求，使用 `AbortController` 控制请求中断。
- 利用 `response.body.getReader()` 读取流数据。
- 采用 `eventsource-parser` 解析 SSE 数据，实时处理消息内容、语音（TTS）、图片等多模态信息。
- 使用定时器实现字符级别的流式显示，支持思考文本与普通文本的分流。

---

**Q4: 遇到错误时，useChat 如何处理和重试？**  
A:

- 错误分为网络错误、业务错误、生成失败和选项生成失败。
- 重试策略包括检查后端是否还在生成，若是则重连会话（SseSessionReconnect），否则重新发送请求（SseFailureRetry）。
- 支持从历史恢复状态和重新生成对话选项，保证聊天连续性。

---

**Q5: useChat 的状态管理有哪些关键点？**  
A:

- 核心状态包括消息列表、对话选项、生成状态（是否正在生成内容和后端状态）及错误状态。
- 支持消息的增删改查和类型识别，管理消息历史和重试逻辑。
- 区分对话选项和故事选项的生成状态，保证多模态场景下的状态同步。

---

**Q6: 在性能优化方面，useChat 做了哪些处理？**  
A:

- 使用 `AbortController` 及时取消请求，避免资源浪费。
- 清理定时器和事件监听，防止内存泄漏。
- 利用 React 的 `useCallback` 和 `useRef` 缓存函数和保存最新值，减少不必要渲染。
- 支持请求重试和流式数据处理，提高网络稳定性。

**Q: 如何在 UI 层不卡顿地做流式增量渲染？**  
A:

- 接收片段
  用 EventSource 或 fetch + ReadableStream 来监听后端 SSE 数据。
- 缓冲 + 合帧
  把每个片段先 push 到一个 bufferRef，再用定时器（16~33ms，大约 1 帧）：为了区分不同语言的吐字速度，还可以做渐显，合并更新，最后 setState。
- 断线恢复
  服务端发送 id: 字段，客户端保存 Last-Event-ID 或自定义 offset，断开后重连时带上，避免丢数据。
- messageId 可以去重。

---
