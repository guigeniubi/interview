# 内存泄漏排查指南

## 快速定位内存泄漏的实战流程（优先级从高到低）

### 1. 问题复现化（必做）

**观察内存增长趋势**（快速判断是泄漏 vs 暂时峰值）

- 在 Performance 选「Memory」选项，点 record，做复现动作，stop。看 memory graph：
  - 持续上涨且不回落 → 泄漏很大概率成立
  - 峰值后迅速回落 → 可能是短期分配/GC 未及时回收
- 记录时间轴上内存上涨点，方便后续在同一时间点抓堆快照

## 常见原因分析

### A. Detached DOM nodes（脱离 DOM 的节点）

**现象：**

- 在 Heap Snapshot 中，有 Detached HTMLDivElement、Detached DOM tree 等类型
- 点击查看 Retainer，会经常发现是某个闭包或事件监听器引用了 DOM 元素

**排查点：**

- 动态 createElement 后忘记 remove 或 remove 后仍被闭包引用
- 使用 innerHTML = ... 销毁节点但保留引用
- 快速检测（控制台）：可用 getEventListeners(el) 查看该元素是否还有监听器（在 Elements 面板选中元素，Console 输入 getEventListeners($0)）

### B. 未清理的定时器/请求/Subscription

**常见类型：**

- setInterval、setTimeout（未 clear）
- 未取消的 requestAnimationFrame
- 未关闭的 WebSocket / SSE / EventSource
- 未 unsubscribe 的 RxJS subscription

**诊断脚本（临时覆盖以监控）：**

```javascript
// 监控定时器
const originalSetInterval = window.setInterval;
window.setInterval = function (...args) {
  console.log("setInterval created:", args);
  return originalSetInterval.apply(this, args);
};
```

### C. 全局缓存 / 单例 Map/Array 没有上限

**现象：**

- 项目级 cache、LRU 未生效、Map/Set 泄漏
- Heap 快照会显示大量同一类型对象（比如大量 Object，且 RetainedSize 大）

**排查点：**

- 查有没有 service 层把 DOM 元素或整个大型对象放进 Cache

### D. 闭包持有大量数据

**现象：**

- 函数闭包引用大量数组/DOM，通常在事件回调或长生命周期回调中出现
- Snapshot 能定位到 closure 对象（Closure 类型），点进去看保留了哪些变量

### E. 第三方库泄漏

**排查方法：**

- 如果 Retainers 链上出现第三方文件路径（例如某个 analytics、video player、carousel）
- 聚焦该库的使用方式（未销毁实例、重复初始化等）

## 后续优化

### 监控与告警

- **采样监控与告警**：在前端埋点或 APM（Sentry / New Relic / Datadog）中监控 performance.memory（Chromium 提供），当连续 N 次上升触发告警并记录堆快照（或性能 trace）

### 长期维护

- **长期内存基线**：分环境建立内存基线（冷启动、浏览 1 分钟、长时间使用），便于比较
- **自动化压力脚本**：用 puppeteer/playwright 模拟高并发翻页和路由切换，并在 CI 中定期运行内存回归测试（防止回归）
